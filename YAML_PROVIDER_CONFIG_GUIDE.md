# YAML-Based Provider Configuration System

## Overview

The VAST Client now supports **declarative YAML-based provider configurations**, eliminating the need for hardcoded Python factory functions. This enables runtime provider registration, easier maintenance, and configuration updates without code changes.

## Migration from Hardcoded Factories

### Old Approach (Deprecated)

```python
# Hardcoded factory functions (DEPRECATED)
from vast_client.config import global_config, tiger_config

config = global_config()  # ⚠️ Deprecated
```

### New Approach (Recommended)

```python
# YAML-based provider configuration
from vast_client import build_provider_client

ad_request = {
    "device_macaddr": "00:11:22:33:44:55",
    "user_agent": "DeviceUA/1.0",
    "placement_type": "switchroll",
    "ext": {
        "domain": "example.com",
        "channel_to": {
            "display_name": "Channel 1",
            "iptvorg_categories": "News"
        }
    }
}

# Build client from YAML configuration
client = await build_provider_client("global", ad_request)

# Client is ready to use
vast_url = client.build_url()
```

## YAML Configuration Structure

Provider configurations are defined in `settings/config.yaml` with the following structure:

```yaml
providers:
  provider_name:
    # Provider metadata
    name: "Display Name"
    description: "Provider description"
    
    # HTTP Client Configuration
    http_client:
      base_url: "https://api.example.com/vast"
      
      # Static parameters (always sent)
      base_params:
        param1: "static_value"
        param2: 123
      
      # Dynamic parameters (template syntax)
      dynamic_params:
        device_id: "${device_serial}"
        placement: "${placement_type|default_value}"
        title: "${channel.display_name}"
      
      # Static headers
      base_headers:
        Accept: "application/xml"
      
      # Dynamic headers (template syntax)
      dynamic_headers:
        User-Agent: "${user_agent}"
        X-Device-Id: "${device_serial}"
      
      # Encoding configuration (per-parameter)
      encoding_config:
        param1: false  # Don't URL-encode
        param2: true   # URL-encode (default)
    
    # IP Pool Configuration
    ip_pools:
      - name: "pool_name"
        strategy: "random"  # Selection strategy
        ips:
          - "192.168.1.1"
          - "192.168.1.2"
        fallback: "192.168.1.1"
    
    # Context Preparation
    context_preparation:
      # Device serial generation
      device_serial:
        type: "uuid_multi_fields"
        fields:
          - "PREFIX"           # Static value
          - "device_macaddr"   # From ad_request
          - "ext.domain"       # Nested path
      
      # Channel data extraction
      channel_extraction:
        display_name: "ext.channel_to.display_name"
        categories: "ext.channel_to.iptvorg_categories"
      
      # IP selection
      ip_selection:
        pool: "pool_name"
        fallback: "192.168.1.1"
    
    # Existing configurations
    tracker: {...}
    parser: {...}
    playback: {...}
```

## Template Variable Syntax

### Simple Substitution
```yaml
dynamic_params:
  user_id: "${user_id}"  # Direct value from context
```

### Nested Path Access
```yaml
dynamic_params:
  channel_name: "${ext.channel_to.display_name}"  # Dot-notation
```

### Default Values
```yaml
dynamic_params:
  placement: "${placement_type|switchroll}"  # Use 'switchroll' if missing
```

### Context Variables

The following variables are available in templates:

**From ad_request (direct access):**
- `${device_macaddr}` - Device MAC address
- `${user_agent}` - User agent string
- `${placement_type}` - Ad placement type

**From ad_request (nested paths):**
- `${ext.domain}` - Domain from request extensions
- `${ext.channel_to.display_name}` - Channel display name
- `${ext.channel_to.iptvorg_categories}` - Channel categories

**Generated by context_preparation:**
- `${device_serial}` - Generated device serial
- `${selected_ip}` - Selected IP from pool
- `${channel.display_name}` - Extracted channel name
- `${channel.categories}` - Extracted channel categories

## Predefined Providers

The following providers are configured out-of-the-box:

### 1. AdStream Global (`global`)
```python
client = await build_provider_client("global", ad_request)
```
- **Endpoint:** `https://g.adstrm.ru/vast3`
- **Features:** City parameters, custom XPaths, 15% interruption rate

### 2. AdStream Tiger (`tiger`)
```python
client = await build_provider_client("tiger", ad_request)
```
- **Endpoint:** `https://t.adstrm.ru/vast3`
- **Features:** Similar to Global, 8% interruption rate

### 3. Leto / Rambler SSP (`leto`)
```python
client = await build_provider_client("leto", ad_request)
```
- **Endpoint:** `https://ssp.rambler.ru/vapirs`
- **Features:** JSON params, different macro format, 5% interruption rate

### 4. Yandex AdFox (`yandex`)
```python
client = await build_provider_client("yandex", ad_request)
```
- **Endpoint:** `https://yandex.ru/ads/adfox/721500/getCodeTest`
- **Features:** Multiple puid parameters, S2S key, 10% interruption rate

## Adding New Providers

To add a new provider, simply edit `settings/config.yaml`:

```yaml
providers:
  my_new_provider:
    name: "My Provider"
    description: "Custom ad provider"
    
    http_client:
      base_url: "https://api.myprovider.com/vast"
      base_params:
        api_key: "your_api_key"
      dynamic_params:
        device_id: "${device_serial}"
      base_headers:
        Accept: "application/xml"
      dynamic_headers:
        User-Agent: "${user_agent}"
      encoding_config: {}
    
    context_preparation:
      device_serial:
        type: "uuid_multi_fields"
        fields: ["MY_PROVIDER", "device_macaddr"]
    
    tracker:
      macro_mapping:
        # Auto-mapping: param_name: MACRO_NAME maps to ad_request.param_name
        # Only list params that need macro substitution
        device_serial: DEVICE_SERIAL  # ad_request.device_serial → [DEVICE_SERIAL]
        user_id: USER_ID              # ad_request.user_id → [USER_ID]
      static_macros:
        AD_SERVER: "My Provider"
    
    playback:
      interruption_rules:
        start:
          probability: 0.10
```

Then use it immediately:

```python
client = await build_provider_client("my_new_provider", ad_request)
```

**No code changes required!**

## API Reference

### `build_provider_client(provider, ad_request, settings=None)`

Build an `EmbedHttpClient` for the specified provider.

**Parameters:**
- `provider` (str): Provider name from YAML config
- `ad_request` (dict): Ad request data for context
- `settings` (Settings, optional): Settings instance

**Returns:**
- `EmbedHttpClient`: Configured HTTP client

**Example:**
```python
client = await build_provider_client("global", {
    "device_macaddr": "00:11:22:33:44:55",
    "user_agent": "DeviceUA/1.0",
    "ext": {"channel_to": {"display_name": "Channel 1"}}
})

url = client.build_url()
headers = client.get_headers()
```

### `EmbedHttpClient.from_provider_config(provider, ad_request, settings=None)`

Alternative factory method on the client class.

**Example:**
```python
from vast_client import EmbedHttpClient

client = await EmbedHttpClient.from_provider_config("global", ad_request)
```

### `ProviderConfigLoader`

Low-level loader for advanced use cases.

```python
from vast_client import ProviderConfigLoader

loader = ProviderConfigLoader()

# Get raw provider config
config = loader.get_provider_config("global")

# Prepare context
context = loader.prepare_context("global", ad_request)

# Build HTTP client config
http_config = loader.build_http_client_config("global", ad_request)
```

### `TemplateResolver`

Template variable resolution utility.

```python
from vast_client import TemplateResolver

context = {"user": "john", "settings": {"theme": "dark"}}

# Simple substitution
result = TemplateResolver.resolve("${user}", context)
# → "john"

# Nested path
result = TemplateResolver.resolve("${settings.theme}", context)
# → "dark"

# Default value
result = TemplateResolver.resolve("${missing|default}", context)
# → "default"

# Resolve dictionary
data = {
    "title": "${user}'s profile",
    "theme": "${settings.theme}"
}
result = TemplateResolver.resolve_dict(data, context)
# → {"title": "john's profile", "theme": "dark"}
```

## Context Preparation

### Device Serial Generation

Generate unique device identifiers from multiple fields:

```yaml
context_preparation:
  device_serial:
    type: "uuid_multi_fields"
    fields:
      - "PROVIDER_PREFIX"  # Static prefix
      - "device_macaddr"   # MAC address
      - "user_agent"       # User agent
      - "ext.domain"       # Domain
```

This generates a deterministic UUID from the concatenation of field values.

### Channel Data Extraction

Extract nested channel data into flat context:

```yaml
context_preparation:
  channel_extraction:
    display_name: "ext.channel_to.display_name"
    categories: "ext.channel_to.iptvorg_categories"
```

Makes `${channel.display_name}` available in templates.

### IP Pool Selection

Select IPs from configured pools:

```yaml
ip_pools:
  - name: "datacenter_1"
    strategy: "random"
    ips: ["192.168.1.1", "192.168.1.2"]
    fallback: "192.168.1.1"

context_preparation:
  ip_selection:
    pool: "datacenter_1"
    fallback: "192.168.1.1"
```

Makes `${selected_ip}` available in headers/params.

## Special Parameter Types

### JSON Parameters

Automatically serialize dictionaries to JSON:

```yaml
dynamic_params:
  jparams:
    type: "json"  # Auto-serialize to JSON string
    value:
      puid8: "10"
      puid25: "iptvportal"
```

Results in: `?jparams={"puid8":"10","puid25":"iptvportal"}`

## Encoding Configuration

Control URL encoding per-parameter:

```yaml
encoding_config:
  city: false        # Keep Cyrillic as-is
  device_id: true    # URL-encode (default)
```

This is useful for parameters that contain non-ASCII characters that should be preserved.

## Migration Checklist

- [ ] Review existing provider factory functions
- [ ] Define providers in `settings/config.yaml`
- [ ] Update code to use `build_provider_client()`
- [ ] Test each provider configuration
- [ ] Remove deprecated factory function calls
- [ ] Update documentation and examples

## Deprecation Timeline

| Version | Status | Notes |
|---------|--------|-------|
| 2.0 | **Deprecation warnings** | Old factories work but warn |
| 2.x | **Migration period** | Both approaches supported |
| 3.0 | **Removal** | Hardcoded factories removed |

## Benefits

✅ **No code changes** for new providers  
✅ **Runtime configuration** updates  
✅ **Centralized** provider definitions  
✅ **Template-based** parameter resolution  
✅ **Type-safe** with validation  
✅ **Maintainable** YAML format  
✅ **Testable** with mock contexts  

## Troubleshooting

### Provider Not Found

```python
ValueError: Provider 'xyz' not found in configuration
```

**Solution:** Check `settings/config.yaml` for the provider definition.

### Template Variable Missing

```
URL contains: ${channel.display_name}
```

**Solution:** Ensure `ad_request` contains the required nested path:
```python
ad_request = {
    "ext": {
        "channel_to": {
            "display_name": "Channel 1"
        }
    }
}
```

### IP Pool Not Found

**Solution:** Verify `ip_pools` section in provider config and `ip_selection.pool` name match.

## Related Documentation

- [VAST Client Documentation](../README.md)
- [Configuration Guide](../settings/README.md)
- [Template Syntax Reference](TEMPLATE_SYNTAX.md)
- [Provider Factory API](API_REFERENCE.md)
